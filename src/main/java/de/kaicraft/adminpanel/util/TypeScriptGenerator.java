package de.kaicraft.adminpanel.util;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.*;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.Diagnostic;
import javax.tools.FileObject;
import javax.tools.StandardLocation;
import java.io.IOException;
import java.io.Writer;
import java.text.SimpleDateFormat;
import java.util.*;

/**
 * Annotation processor that generates TypeScript interfaces from Java classes
 * marked with @TypeScriptType annotation
 */
@SupportedAnnotationTypes("de.kaicraft.adminpanel.util.TypeScriptType")
@SupportedSourceVersion(SourceVersion.RELEASE_21)
public class TypeScriptGenerator extends AbstractProcessor {
    
    private Types typeUtils;
    private Elements elementUtils;
    private Filer filer;
    private Messager messager;
    
    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        typeUtils = processingEnv.getTypeUtils();
        elementUtils = processingEnv.getElementUtils();
        filer = processingEnv.getFiler();
        messager = processingEnv.getMessager();
    }
    
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        if (annotations.isEmpty()) {
            return false;
        }
        
        StringBuilder typescript = new StringBuilder();
        
        // Add header
        typescript.append("// Auto-generated TypeScript definitions\n");
        typescript.append("// Generated on: ").append(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date())).append("\n");
        typescript.append("// DO NOT EDIT - This file is automatically generated from Java source code\n\n");
        
        // Add base types
        typescript.append("/**\n");
        typescript.append(" * Standard API response wrapper\n");
        typescript.append(" */\n");
        typescript.append("export interface ApiResponse<T> {\n");
        typescript.append("  success: boolean;\n");
        typescript.append("  data?: T;\n");
        typescript.append("  message?: string;\n");
        typescript.append("  error?: string;\n");
        typescript.append("}\n\n");
        
        // Process all @TypeScriptType annotated classes
        for (Element element : roundEnv.getElementsAnnotatedWith(TypeScriptType.class)) {
            if (element.getKind() == ElementKind.CLASS) {
                TypeElement typeElement = (TypeElement) element;
                try {
                    String tsInterface = generateInterface(typeElement);
                    typescript.append(tsInterface).append("\n\n");
                } catch (Exception e) {
                    messager.printMessage(Diagnostic.Kind.ERROR, 
                        "Error generating TypeScript for " + typeElement.getSimpleName() + ": " + e.getMessage());
                }
            }
        }
        
        // Write generated TypeScript file
        try {
            FileObject file = filer.createResource(
                StandardLocation.SOURCE_OUTPUT,
                "",
                "../webapp/src/types/generated.ts"
            );
            
            try (Writer writer = file.openWriter()) {
                writer.write(typescript.toString());
            }
            
            messager.printMessage(Diagnostic.Kind.NOTE, 
                "Generated TypeScript definitions at: webapp/src/types/generated.ts");
                
        } catch (IOException e) {
            messager.printMessage(Diagnostic.Kind.ERROR, 
                "Failed to write TypeScript file: " + e.getMessage());
        }
        
        return true;
    }
    
    private String generateInterface(TypeElement typeElement) {
        StringBuilder sb = new StringBuilder();
        
        // Get custom name or use class name
        TypeScriptType annotation = typeElement.getAnnotation(TypeScriptType.class);
        String interfaceName = annotation.value().isEmpty() ? 
            typeElement.getSimpleName().toString() : 
            annotation.value();
        
        // Add JSDoc comment
        sb.append("/**\n");
        sb.append(" * ").append(interfaceName).append("\n");
        String docComment = elementUtils.getDocComment(typeElement);
        if (docComment != null && !docComment.trim().isEmpty()) {
            sb.append(" * ").append(docComment.trim()).append("\n");
        }
        sb.append(" */\n");
        
        // Start interface
        sb.append("export interface ").append(interfaceName).append(" {\n");
        
        // Process fields
        for (Element enclosedElement : typeElement.getEnclosedElements()) {
            if (enclosedElement.getKind() == ElementKind.FIELD) {
                VariableElement field = (VariableElement) enclosedElement;
                
                // Skip static fields
                if (field.getModifiers().contains(Modifier.STATIC)) {
                    continue;
                }
                
                String fieldName = field.getSimpleName().toString();
                String tsType = javaTypeToTypeScript(field.asType().toString());
                
                sb.append("  ").append(fieldName).append(": ").append(tsType).append(";\n");
            } else if (enclosedElement.getKind() == ElementKind.CLASS) {
                // Handle nested classes
                TypeElement nestedClass = (TypeElement) enclosedElement;
                if (nestedClass.getModifiers().contains(Modifier.STATIC)) {
                    // Generate nested interface separately (will be processed in next iteration)
                }
            }
        }
        
        sb.append("}");
        
        return sb.toString();
    }
    
    /**
     * Convert Java type to TypeScript type
     */
    private String javaTypeToTypeScript(String javaType) {
        // Remove package names
        String simpleType = javaType.contains(".") ? 
            javaType.substring(javaType.lastIndexOf('.') + 1) : javaType;
        
        // Handle primitive types
        switch (simpleType) {
            case "int":
            case "long":
            case "short":
            case "byte":
            case "float":
            case "double":
            case "Integer":
            case "Long":
            case "Short":
            case "Byte":
            case "Float":
            case "Double":
                return "number";
            case "boolean":
            case "Boolean":
                return "boolean";
            case "String":
            case "char":
            case "Character":
                return "string";
            case "void":
            case "Void":
                return "void";
            default:
                // Handle arrays
                if (simpleType.endsWith("[]")) {
                    String elementType = simpleType.substring(0, simpleType.length() - 2);
                    return javaTypeToTypeScript(elementType) + "[]";
                }
                
                // Handle generic types (List<T>, Map<K,V>, etc.)
                if (simpleType.startsWith("List<") || simpleType.startsWith("ArrayList<")) {
                    String genericType = extractGenericType(simpleType);
                    return javaTypeToTypeScript(genericType) + "[]";
                }
                
                if (simpleType.startsWith("Map<") || simpleType.startsWith("HashMap<")) {
                    String[] types = extractMapTypes(simpleType);
                    return "Record<" + javaTypeToTypeScript(types[0]) + ", " + javaTypeToTypeScript(types[1]) + ">";
                }
                
                if (simpleType.startsWith("Optional<")) {
                    String genericType = extractGenericType(simpleType);
                    return javaTypeToTypeScript(genericType) + " | null";
                }
                
                // Handle Set
                if (simpleType.startsWith("Set<") || simpleType.startsWith("HashSet<")) {
                    String genericType = extractGenericType(simpleType);
                    return javaTypeToTypeScript(genericType) + "[]";
                }
                
                // Default: use as-is (assume it's another generated interface)
                return simpleType.replaceAll("<.*>", ""); // Remove generics for now
        }
    }
    
    private String extractGenericType(String type) {
        int start = type.indexOf('<') + 1;
        int end = type.lastIndexOf('>');
        if (start > 0 && end > start) {
            return type.substring(start, end).trim();
        }
        return "any";
    }
    
    private String[] extractMapTypes(String type) {
        int start = type.indexOf('<') + 1;
        int end = type.lastIndexOf('>');
        if (start > 0 && end > start) {
            String generics = type.substring(start, end);
            String[] parts = generics.split(",");
            if (parts.length == 2) {
                return new String[]{parts[0].trim(), parts[1].trim()};
            }
        }
        return new String[]{"string", "any"};
    }
}
